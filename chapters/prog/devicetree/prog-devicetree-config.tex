\section{Configuration using devicetrees}
Since we're using a microcontroller that is widely available, most of the work with
devicetrees has already been done by the manufacturer.

Thus, we don't need to care about memory, cpus, or other internals details of the
peripherals. We only edit properties that are related to our needs, which include
peripherals or other ICs.

All of the structure was automatically generated by a tool provided by the manufacturer,
that create an empty structure with everything needed to ensure the boot of the controller.

\paragraph{}
To make the structure cleaner, we've used a lot of overlays, because it's much easier
to debug and find the right property when needed.

\subsection{Main overlays}
Thus, the generated file has only a new line : the one needed to include the main overlay file.

This file look like this :

\inputminted[linenos, firstline=16, lastline=44]{devicetree}{\DeviceTree/topaze-pinctrl.dtsi}

This file is not a properly formed overlay, since it does indeed overlay nothing. But it make our
job easier by grouping all of the sub includes into a single file. Then, we can modify them for
debugging purposes.

We'll quickly move to another file that show a real overlay file, such as the PWM and I2C configuration.

\subsection{Peripherals overlays}
\subsubsection{PWM configuration}
Then, let's open a file like the PWM configuration to explore more in details what an overlay is.
For any overlay file, we used four main blocks\footnote{
    The number of block may vary depending on each architecture and software decision.
}, which are

\begin{itemize}
    \item Global peripheral configuration
    \item Pin configuration
    \item Advanced peripheral configuration
    \item Aliases
\end{itemize}

\paragraph{Global peripheral configuration} ~\\
First, we need to configure globally the peripheral.
\inputminted[linenos, firstline=17, lastline=21]{devicetree}{\DeviceTree/topaze-pwm-servo.dtsi}

Here, we're simply enabling the peripheral by setting it's status property to "okay". Then, we're
passing a reference to a pinctrl configuration, charged to define the pins. \footnote{
    The default name is mandatory, and is used by the RTOS to know what to do with theses pins once
    placed in low power modes. We're not using them here.
}

\paragraph{Pin configuration} ~\\
Then, right after, we're configuring the said pins. We pass a group of pins that are defined by a
macro, that return the pin number according input like the port, the pin, and some description.

\inputminted[linenos, firstline=24, lastline=33]{devicetree}{\DeviceTree/topaze-pwm-servo.dtsi}

As previously said, we're not using low power modes so we don't need them in our project. If they
were defined, we would see here two group of pins, one for each mode.

\paragraph{Advanced peripheral configuration} ~\\
Now, the main configuration part. That's where we configure most of the behavior of the PWM peripheral.

\paragraph{}
Before entering into the main details, we need to explain something : We created a node named "wings" here,
that is compatible with pwm-wings. This is a custom wrote specification for our needs that wait for
\begin{itemize}
    \item A pwm array with exactly four pwm channels
    \item A pwm period
    \item Some boundaries about the duty cycle (expressed in time domain)
\end{itemize}

\inputminted[linenos, firstline=52, lastline=66]{devicetree}{\DeviceTree/topaze-pwm-servo.dtsi}

Thus, we find here our custom node with our four servo-engines defined, and some settings.
Not all settings are used by the PWM peripheral to configure itself, but by the software that
import them as constants.\footnote{
    For example, min-pulse and max-pulse are used by the software to compute the required
    pulse for a defined angle.
}

\paragraph{Aliases} ~\\
Then, to conclude on this file, we define some aliases. Theses enabled the fetching of a node by quoting
it's name rather than it's location.

\inputminted[linenos, firstline=69, lastline=74]{devicetree}{\DeviceTree/topaze-pwm-servo.dtsi}

\subsubsection{I2C configuration}
Then, in the same manner we configured the I2C \footnote{
    And a lot of other peripherals !
}. The file expose the same structure, as any overlay in the project.

\inputminted[linenos, firstline=36, lastline=61]{devicetree}{\DeviceTree/topaze-I2C.dtsi}

The main difference with the previous file is the presence of multiple nodes here, once for each I2C sensor.
Each device can has some properties, such a compatible, status and reg properties. The last one, reg,
correspond to it's address on the bus ! Thus, we don't care about such details on the software, we communicate
with a sensor, not a peripheral on some address.

\subsection{Final words}
To conclude this part, let's resume a bit the devicetree files. Theses are used for hardware related configuration,
and expose some options that may be used to directly configure the registers of an IC, or be exposed to a C or C++
as constants for more advanced usage. They're used by the underlying OS on the MCU while the pre-kernel boot.

Theses files are complex to write, but can be used to configure precisely the differents hardware while reducing
user errors.
